---
title: Flow fields (12 Months of aRt, September)
author: Will
date: '2019-09-30'
slug: flow-fields-12-months-of-art-september
categories:
  - Art
  - R
tags:
  - aRt
  - ggplot
  - Math
  - tutorials
authors: []
header:
  caption: ''
  image: ''
  preview: yes
---



<p>Flow fields are something weâ€™ve circled for a while now. Back in February I wrote about strange attractors, which are a sort of flow field, and last month we explored noise functions, which is the perfect groundwork for todayâ€™s topic. A flow field is simply a grid of vectors, which is to say, itâ€™s a grid of numbers. Flow fields can be generated by attractor functions, images, magnetic fields, wind, or what we will focus on today, noise functions.</p>
<div id="particles" class="section level1">
<h1>Particles</h1>
<p>You can visualize flow fields using arrows, glyphs, or as we will do now, particles. Thomas Lin Pedersenâ€™s <code>particles</code> package will provide a useful interface for us to release some particles and let them flow through our field recording their position. We will then track the path of the particles which reveals the structure of our flow field. To make a particles picture out of a flow field, weâ€™ll set up some particles and then run a simulation with a low velocity on the particles and allow the system to evolve over 50 or 100 generations. We will steer the particles according to our flow field values, which can be converted from noise values to angles by normalizing to (-1, 1) and multiplying by 2Ï€. I recommend reading of the <code>particles</code> <a href="https://cran.r-project.org/web/packages/particles/vignettes/intro.html" target="_blank">vignette</a> which is very helpful in understanding how to set up a simulation.</p>
<pre class="r"><code>library(tidyverse)
library(ambient)
library(particles)
library(tidygraph)

#create noise field
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000)) %&gt;%
  mutate(noise = gen_simplex(x, y))

#convert noise values to a matrix of angles
field &lt;- as.matrix(grid, x, value = normalize(noise, to = c(-1, 1))) * (2 * pi)

#particle simulation, taken from {particles} vignette
sim &lt;- create_ring(1000) %&gt;% 
  simulate(alpha_decay = 0, setup = aquarium_genesis()) %&gt;% 
  wield(reset_force, xvel = 0, yvel = 0) %&gt;% 
  wield(field_force, angle = field, vel = 0.1, xlim = c(-5, 5), ylim = c(-5, 5)) %&gt;% 
  evolve(100, record)

traces &lt;- data.frame(do.call(rbind, lapply(sim$history, position)))
names(traces) &lt;- c(&#39;x&#39;, &#39;y&#39;)
traces$particle &lt;- rep(1:1000, 100)

#plot particle traces
ggplot(traces) +
  geom_path(aes(x, y, group = particle), size = 0.1) + 
  theme_void() + 
  theme(legend.position = &#39;none&#39;)</code></pre>
<p><img src="/post/2019-09-30-flow-fields-12-months-of-art-september_files/figure-html/unnamed-chunk-2-1.png" width="960" /></p>
<div id="curl-noise" class="section level2">
<h2>Curl noise</h2>
<p>This isnâ€™t necessarily wrong, but itâ€™s not quite the look I want. Normal noise functions produce flow fields with lots of sinks, meaning that after a few generations of the simulation, all of the particles will converge on some valleys and remain there. This is why you see a bunch of dark lines with only a couple smaller lines coming out in this render. If we want a field that looks more fluid, we can use curl noise to produce a divergence-free flow field. Fields with sinks and gutters are said to have <em>divergence</em> but by applying curl noise to any continuous field like perlin or simplex noise, we can transform it to a form more suitable for our purposes.</p>
<pre class="r"><code>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000)) %&gt;%
  mutate(noise = gen_simplex(x, y))

curl &lt;- curl_noise(gen_perlin, x = grid$x, y = grid$y)

grid$angle &lt;- atan2(curl$y, curl$x) - atan2(grid$y, grid$x)

field &lt;- as.matrix(grid, x, value = angle)

sim &lt;- create_empty(1000) %&gt;% 
  simulate(alpha_decay = 0, setup = aquarium_genesis(vel_max = 0)) %&gt;% 
  wield(reset_force, xvel = 0, yvel = 0) %&gt;% 
  wield(field_force, angle = field, vel = 0.1, xlim = c(-5, 5), ylim = c(-5, 5)) %&gt;% 
  evolve(100, record)

traces &lt;- data.frame(do.call(rbind, lapply(sim$history, position)))
names(traces) &lt;- c(&#39;x&#39;, &#39;y&#39;)
traces$particle &lt;- rep(1:1000, 100)

ggplot(traces) +
  geom_path(aes(x, y, group = particle), size = 0.3, alpha = 0.5) + 
  theme_void() + 
  theme(legend.position = &#39;none&#39;)</code></pre>
<p><img src="/post/2019-09-30-flow-fields-12-months-of-art-september_files/figure-html/unnamed-chunk-3-1.png" width="960" /></p>
<p>Certainly that looks much more fluid, now letâ€™s examine how we handle curl noise. The <code>curl_noise()</code> function from ambient gives a transformed <code>x</code> and <code>y</code> for our original grid. When I first tested this, I didnâ€™t realize you could actually feed these new coordinates directly to <code>wield()</code>, so instead I calculated the angle between the original point and the new point using some trigonometry. When I went back and tested it by directly plugging in the coordinates, I didnâ€™t get the same type of fluid field result. I canâ€™t nail down what exactly Iâ€™m doing wrong, but since my trig solution seems to produce something nice looking, Iâ€™m sticking with it (though be warned, itâ€™s very possible I made a mistake here too and this is all just a happy accident ðŸ˜‰).</p>
<p>From here the choice is yours. Use different noise parameters, try different particle layouts or velocities, different numbers of generations, grid sizes, colors, and anything else you can think of. One parameter I had fun playing with is <code>xlim</code> and <code>ylim</code> in <code>wield()</code>. These set the coordinate span in the x or y direction of our vector field. Iâ€™m sure you should set these to the actual span of your noise grid, but I just started setting them to random values and stumbled upon some lovely mistakes. I found that the sweet spot for a 1000x1000 grid is between 10 and 100. Hereâ€™s an example of messing with these parameters and adding color.</p>
<pre class="r"><code>seed &lt;- sample(1:2000, 1)

grid &lt;-
  long_grid(x = seq(0, 10, length.out = 1000), 
            y = seq(0, 10, length.out = 1000)) %&gt;% 
  mutate(
    x1 = x + gen_perlin(x = x, y = y, frequency = 2, seed = seed), 
    y1 = y + gen_perlin(x = x, y = y, frequency = 0.5, seed = seed)
  )

curl &lt;- curl_noise(gen_perlin, seed = seed, x = grid$x1, y = grid$y1)

grid$angle &lt;- atan2(curl$y, curl$x) - atan2(grid$y, grid$x)

field &lt;- as.matrix(grid, x, value = angle)

sim &lt;- create_ring(10000) %&gt;% 
  simulate(alpha_decay = 0, setup = petridish_genesis(vel_max = 0, max_radius = 1)) %&gt;% 
  wield(reset_force, xvel = 0, yvel = 0) %&gt;% 
  wield(field_force, angle = field, vel = 0.15, xlim = c(-50, 40), ylim = c(-50, 40)) %&gt;% 
  evolve(100, record)

traces &lt;- data.frame(do.call(rbind, lapply(sim$history, position)))
names(traces) &lt;- c(&#39;x&#39;, &#39;y&#39;)
traces$particle &lt;- rep(1:10000, 100)

bl_yl &lt;- c(&#39;#4CA66B&#39;, &#39;#00b2dd&#39;)
bl_yl_bg &lt;- &#39;#EEEEEE&#39;

traces2 &lt;- 
  traces %&gt;%
  group_by(particle) %&gt;%
  mutate(color = sample(bl_yl, 1, replace = TRUE))

ggplot(traces2) +
  geom_path(aes(x, y, group = particle, color = color), size = 0.035, alpha = 0.6) + 
  scale_color_identity(guide = &quot;none&quot;) +
  theme_void() + 
  theme(legend.position = &#39;none&#39;, panel.background = element_rect(fill = bl_yl_bg))</code></pre>
<p><img src="/post/2019-09-30-flow-fields-12-months-of-art-september_files/figure-html/unnamed-chunk-4-1.png" width="960" /></p>
</div>
</div>
<div id="polygons" class="section level1">
<h1>Polygons</h1>
<p>Particles are just one of many ways to visualize flow fields. Here Iâ€™ll demonstrate another using polygons. This time weâ€™ve got our original noise grid, then we can calculate angles directly from the noise grid, or compute the angles of the curl of the noise. We will map noise to some parameters like size and/or color, and map the polygon angle to the angle weâ€™ve calculated for our grid. This makes use of <code>geom_regon()</code> from the ggforce package to render polygons of n sides at each point in our grid.</p>
<pre class="r"><code>library(ggforce)

seed &lt;- 111

grid &lt;- long_grid(seq(1, 10, length.out = 50), seq(1, 10, length.out = 50)) %&gt;%
  mutate(noise = gen_perlin(x, y, seed = seed))

curl &lt;- curl_noise(gen_perlin, seed = seed, x = grid$x, y = grid$y)

grid$angle &lt;- atan2(curl$y, curl$x) - atan2(grid$y, grid$x)

ggplot(grid) +
  geom_regon(aes(x0 = x, y0 = y, r = noise/3, angle = angle, sides = 3, fill = noise), alpha = 0.75) +
  scale_fill_gradientn(colors = c(&quot;#FFC1C1&quot;, &quot;#C6B6E0&quot;, &quot;#C6B6E0&quot;, &quot;#326983&quot;), guide = &quot;none&quot;) +
  theme_void()</code></pre>
<p><img src="/post/2019-09-30-flow-fields-12-months-of-art-september_files/figure-html/unnamed-chunk-5-1.png" width="960" /></p>
<p>Just like with particles, we can change all sorts of parameters, like color, transparency, types of polygons, types of noise, etc. Here letâ€™s try a fun variation with worley noise.</p>
<pre class="r"><code>seed &lt;- sample(1:1000, 1)

grid &lt;-
  long_grid(x = seq(0, 10, length.out = 60), 
            y = seq(0, 10, length.out = 60)) %&gt;% 
  mutate(noise = gen_worley(x, y, seed = seed))

curl &lt;- curl_noise(gen_worley, seed = seed, x = grid$x, y = grid$y)

grid$angle &lt;- atan2(curl$y, curl$x) - atan2(grid$y, grid$x)

ggplot(grid) +
  geom_regon(aes(x0 = x, y0 = y, r = noise/4, sides = 4, fill = noise, angle = angle), alpha = 0.8) +
  scale_fill_gradientn(colors = c(&quot;#009A72&quot;, &quot;#2AA57E&quot;, &quot;#6DB089&quot;, &quot;#B9BA94&quot;, &quot;#FFC4A0&quot;, &quot;#FFAA94&quot;, &quot;#FFA198&quot;, &quot;#FFA9A8&quot;, &quot;#FAC4C6&quot;), guide = &quot;none&quot;) +
  theme_void()</code></pre>
<p><img src="/post/2019-09-30-flow-fields-12-months-of-art-september_files/figure-html/unnamed-chunk-6-1.png" width="960" /></p>
</div>
<div id="more-pretty-pictures" class="section level1">
<h1>More pretty pictures</h1>
<p>I hope youâ€™ve enjoyed this post, and maybe learned something? If nothing else, perhaps youâ€™ve seen that sometimes, itâ€™s OK to not really understand whatâ€™s going on with generative art. A lot of these experiments were things I stumbled upon by accident or in pursuit of something else. Take what comes your way, and remember itâ€™s about the art, not the code. Speaking of the code, you can find it, along with more pictures <a href="https://github.com/will-r-chase/aRt" target="_blank">on my GitHub</a>.</p>
<p>Hereâ€™s a selection of some of my favorite particle fields I made while exploring this month.</p>
<p><img src="/img/curl4.png">
<img src="/img/curl8_seed15.png">
<img src="/img/curl8_seed230.png">
<img src="/img/curl6_seed544.png"></p>
</div>
